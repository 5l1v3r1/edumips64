<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org">

    <title></title>
  </head>

  <body>
    <table width="600" align="center">
      <tr>
        <td>
          <h2>INSTRUCTION SET EDUMIPS64<br>
          =========================</h2>

          <p>Guida veloce all'instruction set di EduMIPS64. Alcune descrizioni sono prese dal <br>
            manuale MIPS64. Fateci sapere se questo e' un problema, e le rimuoveremo.</p>
          <p>Istruzione AND </p>
          <p>Sintassi: AND rd, rs, rt <br>
            Descrizione: rd = rs and rt<br>
            Effettua un AND logico bit a bit tra il registro rs ed il registro rt.<br>
            Mette il risultato nel registro rd.<br>
  <br>
  <br>
            Istruzione ANDI </p>
          <p>Sintassi: ANDI rt, rs, immediato<br>
            Descrizione: rt = rs AND immediato<br>
            Effettua un AND logico bit a bit tra il registro rs ed un immediato.<br>
            L'immediato a 16 bit &quot;is zero-extended to the left&quot; e successivamente<br>
            viene effettuato l'AND bit a bit. Il risultato viene memorizzato nel <br>
            registro rt.<br>
  <br>
            Istruzione BEQ </p>
          <p>Sintassi: BEQ rs, rt, offset<br>
            Descrizione: if rs = rt then branch<br>
            Confronta i GPR rs ed rt ed effettua un salto condizionale.<br>
  <br>
            Istruzione BEQZ </p>
          <p>Sintassi: BEQZ rs, offset<br>
            Descrizione: if rs == 0 then branch<br>
            Verifica il valore di un GPR ed effettua un salto condizionale.<br>
  <br>
            Istruzione BNE </p>
          <p>Sintassi: BNE rt, rs, offset<br>
            Descrizione: if rs != rt then branch<br>
            Verifica il valore di un GPR ed effettua un salto condizionale.<br>
  <br>
            Istruzione BNEZ </p>
          <p>Sintassi: BNEZ rs, offset<br>
            Descrizione: if rs != 0 then branch <br>
            Verifica il valore di un GPR ed effettua un salto condizionale.<br>
  <br>
            Istruzione DADD </p>
          <p>Sintassi: DADD rd, rs, rt<br>
            Descrizione: <br>
            Somma due interi a 64 bit. Lancia un'eccezione in caso di overflow.<br>
  <br>
            Istruzione DADDI </p>
          <p>Sintassi: DADDI rt, rs, immediate<br>
            Descrizione: <br>
            Somma una costante ad un intero a 64 bit. Lancia un'eccezione in caso di overflow.</p>
          <p>Istruzione DADDU </p>
          <p>Sintassi: DADDU rd, rs, rt<br>
            Descrizione: rd = rs + rt<br>
            Somma due interi a 64 bit.<br>
            Il valore a 64 bit del GPR rt e' sommato al valore a 64 bit del registro rs, <br>
            il risultato e' memorizzato nel registro rd.<br>
            Non si verificano eccezioni di overflow.<br>
  <br>
            Istruzione DADDUI </p>
          <p>Sintassi: DADDUI rt, rs, immediate<br>
            Descrizione: <br>
            Somma una costante ad un registro a 64 bit.<br>
            L'immediato con segno e' sommato al valore a 64 bit del GPR rs,<br>
            il risultato e' memorizzato nel registro rt.<br>
            Non si verificano eccezioni di overflow.</p>
          <p>Istruzione DDIV </p>
          <p>Sintassi: DDIV rs, rt<br>
            Descrizione: (LO, HI) = rs / rt<br>
            Effettua la divisione tra due interi a 64 bit.<br>
            Divide il valore a 64 bit del registro rs con quello nel registro rt,<br>
            considerando entrambi gli operandi come valori con segno.<br>
            Il quoziente ed il resto a 64 bit sono memorizzati rispettivamente,<br>
            nei registri speciali LO ed HI.<br>
            Non si verificano eccezioni di aritmetiche.<br>
  <br>
            Istruzione DMULT </p>
          <p>Sintassi: DMULT rs, rt<br>
            Descrizione: (LO) = rs * rt<br>
            Moltiplica due interi con segno a 64 bit.<br>
            Il valore nel registro rt e' moltiplicato per il valore in rs,<br>
            considerando entrambi gli operandi come valori con segno.<br>
  <br>
            Istruzione DSLL </p>
          <p>Sintassi: DSLL rd, rt, sa Doubleword shift left logical<br>
            Descrizione: <br>
            Effettua uno shift a sinistra del valore a 64 bit di un numero di <br>
            bit fisso che varia da 0 a 31.<br>
            I valori a 64 bit sono shiftati a sinistra, inserendo degli zeri nei bit<br>
            vuoti, il risultato e' memorizzato nel registro rd.<br>
            Il numero di bit di cui shiftare il valore e' specificato dal registro sa.<br>
  <br>
            Istruzione DSLLV </p>
          <p>Sintassi: DSLLV rd, rs, rt<br>
            Descrizione: <br>
            Effettua uno shift a sinistra di un valore a 64 bit di un numero variabile<br>
            di bit. I 64 bit contenuti nel GPR vengono shiftati a sinistra, <br>
            inserendo degli zeri nei bit vuoti, il risultato e' memorizzato nel registro rd.<br>
  <br>
            Istruzione DSRA </p>
          <p>Format: DSRA rd, rt, sa<br>
            Descrizione: <br>
            Effettua uno shift aritmetico a destra di un numero fisso di bit, variabile tra 0 e 31, <br>
            del valore a 64 bit.<br>
  <br>
            Istruzione DSRAV </p>
          <p>ormat: DSRAV rd, rs, rt<br>
            Descrizione: rd = rt &gt;&gt; rs (arithmetic)<br>
            Effettua uno shift aritmetico di un numero variabile di bit.<br>
            Il valore a 64 bit contenuto nel GPR rt e' shiftato a destra, duplicando <br>
            il bit di segno (63) nei bit vuoti, il risultato e' memorizzato nel registro rd.<br>
  <br>
            Istruzione DSRL </p>
          <p>Sintassi: DSRL rd, rt, sa<br>
            Descrizione: <br>
            Effettua uno shift logico a destra di una doubleword per un numero fisso di bit<br>
            da 0 a 31. Il valore a 64 bit contenuto nel GPR rt e' shiftato a destra inserendo degli<br>
            zeri nei bit vuoti, il risultato e' memorizzato nel registro rd.<br>
  <br>
            Istruzione DSRLV </p>
          <p>Sintassi:      DSRLV rd, rs, rt<br>
            Descrizione: <br>
            Effettua uno shift logico a destra di una doubleword per un numero variabile di bit.<br>
            Il valore a 64 bit contenuto nel GPR rt e' shiftato a destra inserendo degli<br>
            zeri nei bit vuoti, il risultato e' memorizzato nel registro rd.<br>
  <br>
            Istruzione DSUB </p>
          <p>Sintassi: DSUB rd, rs, rt<br>
            Descrizione: <br>
            Sottrae due interi a 64 bit. Se si verifica un overflow, lancia un'eccezione.<br>
            Il valore a 64 bit del registro rt e' sottratto a quello contenuto nel registro rs,<br>
            il risultato e' posto in rd.<br>
  <br>
            Istruzione DSUBU </p>
          <p>Sintassi: DSUBU rd, rs, rt<br>
            Descrizione: <br>
            Sottrae due interi a 64 bit senza segno. Se si verifica un overflow, lancia un'eccezione.<br>
            Il valore a 64 bit del registro rt e' sottratto a quello contenuto nel registro rs,<br>
            il risultato e' posto in rd.</p>
          <p>Istruzione HALT </p>
          <p>Sintassi:    HALT<br>
            Descrizione: <br>
            Termina l'esecuzione del programma.<br>
            Quando un'istuzione HALT effettua lo stadio ID, notifica alla CPU<br>
            che tutte le istruzioni della pipeline successive alla HALT devono<br>
            essere ignorate.<br>
            Eccezioni:   HaltException</p>
          <p>Istruzione J </p>
          <p>Sintassi: J targetJ<br>
            Descrizione: <br>
            Salta entro la regione corrente allineata a 256 MB. <br>
            E' un salto PC-region (non PC-relative); l'effettivo<br>
            indirizzo e' nella regione corrente allineata a 256 MB.<br>
  <br>
            Istruzione JAL </p>
          <p>Sintassi: JAL target<br>
            Descrizione: <br>
            Esegue una chiamata di procedura all'interno della regione corrente<br>
            allineata a 256 MB. Inserisce l'indirizzo di ritorno nel GPR 31. <br>
            E' un salto PC-region (non PC-relative).<br>
  <br>
            Istruzione JALR </p>
          <p>Sintassi: JALR rs<br>
            Descrizione: <br>
            Esegue una chiamata di procedura all'indirizzo di un'istruzione contenuto<br>
            in un registro. Inserisce l'indirizzo di ritorno nel GPR rd.<br>
  <br>
            Istruzione JR </p>
          <p>Sintassi: JR rs<br>
            Descrizione: <br>
            Esegue un salto ad un indirizzo di un'istruzione contenuto in un registro.<br>
  <br>
            Istruzione LB </p>
          <p>Sintassi: LB rt, offset(base)<br>
            Descrizione: rt = memory[base+offset]<br>
            Carica un byte dalla memoria come valore con segno.<br>
  <br>
            Istruzione LBU </p>
          <p>Sintassi: LBU rt, offset(base)<br>
            Descrizione: rt = memory[base+offset]<br>
            Carica un byte dalla memoria come valore con segno.<br>
  <br>
            Istruzione LD </p>
          <p>Sintassi: LD rt, offset(base)<br>
            Descrizione: rt = memory[base+offset]<br>
            Carica una doubleword dalla memoria.<br>
  <br>
            Istruzione LH </p>
          <p>Sintassi: LH rt, offset(base)<br>
            Descrizione: rt = memory[base+offset]<br>
            Carica un'halfword dalla memoria come valore con segno.<br>
  <br>
            Istruzione LHU <br>
  <br>
            Sintassi: LHU rt, offset(base)<br>
            Descrizione:  rt = memory[base+offset] <br>
            Carica un'halfword dalla memoria come valore senza segno.<br>
            Istruzione LH </p>
          <p>Sintassi: LH rt, offset(base)<br>
            Descrizione: rt = memory[base+offset]<br>
            Carica una halfword dalla memoria come valore con segno.<br>
  <br>
            Istruzione LHU </p>
          <p>Sintassi: LHU rt, offset(base)<br>
            Descrizione:  rt = memory[base+offset] <br>
            Carica una halfword dalla memoria come valore senza segno.<br>
  <br>
            Istruzione LUI </p>
          <p>Format: LUI rt, rs, immediate<br>
            Descrizione: <br>
            L'immediato a 16 bit e' shiftato a sinistra e concatenata con zeri nei 16 bit <br>
            meno significativi.<br>
  <br>
            Istruzione LW </p>
          <p>Format: LW rt, offset(base)<br>
            Descrizione:   rt = memory[base+offset]<br>
            Carica una word dalla memoria come valore con segno.</p>
          <p>Istruzione LWU </p>
          <p>Sintassi: LWU rt, offset(base)<br>
            Descrizione:   rt = memory[base+offset]<br>
            Carica una word dalla memoria come valore senza segno.</p>
          <p>Istruzione MFHI </p>
          <p>Sintassi: MFHI rd<br>
            Descrizione: rd = HI<br>
            Copia il registro speciale HI nel GPR rd.<br>
  <br>
            Istruzione MFLO </p>
          <p>Sintassi: MFLO rd<br>
            Descrizione: rd = LO<br>
            Copia il registro speciale HI nel GPR rd.<br>
  <br>
            Istruzione MOVN </p>
          <p>Sintassi: MOVN rd, rs, rt <br>
            Descrizione: if rt != 0 then rd = rs<br>
            Se il valore del registro rt non e' uguale a zero il contenuto <br>
            viene copiato nel registro rd.<br>
  <br>
            Istruzione MOVZ </p>
          <p>Sintassi: MOVZ rd, rs, rt<br>
            Descrizione: if rt = 0 then rd = rs<br>
            Se il valore del registro rt non e' uguale a zero il contenuto <br>
            viene copiato nel registro rd.<br>
  <br>
            Istruzione NOP </p>
          <p>Sintassi: NOP<br>
            Descrizione:<br>
            Crea spazi vuoti nella pipeline.</p>
          <p>Istruzione OR </p>
          <p>Sintassi: OR rd, rs, rt<br>
            Descrizione: rd = rs or rt <br>
            Effettua un OR logico bit a bit.<br>
            L'operazione di OR logico bit a bit e' effettuata tra il valore<br>
            contenuto nel registro rs e quello contenuto nel registro rt.<br>
  <br>
            Istruzione ORI </p>
          <p>Sintassi: ORI rt, rs, immediate<br>
            Descrizione: <br>
            Effettua un OR logico bit a bit con una costante.</p>
          <p>Istruzione SB </p>
          <p>Sintassi: SB rt, offset(base)<br>
            Descrizione: memory[base+offset] = rt<br>
            Memorizza gli 8 bit meno significativi di rt in memoria.<br>
  <br>
            Istruzione SD </p>
          <p>Sintassi: SD rt, offset(base)<br>
            Descrizione: memory[base+offset] = rt<br>
            Memorizza la doubleword contenuta in rt in memoria.<br>
  <br>
            Istruzione SH </p>
          <p>Sintassi: SH rt, offset(base)<br>
            Descrizione: memory[base+offset] = rt<br>
            Memorizza l'halfword contenuta in rt in memoria.<br>
  <br>
            Istruzione SLTIU </p>
          <p>Sintassi: SLTIU rt, rs, immediate<br>
            Descrizione: <br>
            Memorizza il risultato del confronto di minoranza tra il registro rs <br>
            ed una costante senza segno. Pone il risultato nel registro rt.<br>
            Se il registro rs contiene un valore minore dell'immediato, rt viene<br>
            posto ad 1 (true), altrimenti viene posto a 0 (false). <br>
  <br>
            Istruzione SLTU </p>
          <p>Sintassi: SLT rd, rs, rt<br>
            Descrizione: <br>
            Memorizza il risultato del confronto rs&lt;rt nel GPR rd.<br>
            Non si verifica alcuna eccezione di overflow.<br>
  <br>
            Istruzione SW </p>
          <p>Sintassi: SW rt, offset(base)<br>
            Descrizione: rt = memory[base+offset]<br>
            Memorizza in memoria un byte, aggiungengo l'offset con segno <br>
            all'indirizzo base per formare l'indirizzo finale.<br>
  <br>
            Istruzione XOR </p>
          <p>Sintassi: XOR rd, rs, rt<br>
            Descrizione: rd = rs XOR rt<br>
            Effettua l'OR esclusivo tra i valori contenuti nei registri rs ed rt.<br>
  <br>
            Istruzione XORI </p>
          <p>Sintassi: XORI rt, rs, immediate<br>
            Descrizione: rt = rs XOR immediate<br>
            Effettua l'OR esclusivo con una costante.<br>
          </p>
          <p><br>
          </p></td>
      </tr>
    </table>
  </body>
</html>

